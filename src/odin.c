// Automatically generated by odin 1.5.10 - do not edit
#include <float.h>
#include <R.h>
#include <Rmath.h>
#include <Rinternals.h>
#include <stdbool.h>
#include <R_ext/Rdynload.h>
typedef struct model_sr_internal {
  double a;
  double A_r0;
  double A_s0;
  double b;
  double cA;
  double cD;
  double cT;
  double D_r0;
  double D_s0;
  int *delay_index_delayed_lambda_v_r_Sv;
  int *delay_index_delayed_lambda_v_s_Sv;
  double *delay_state_delayed_lambda_v_r_Sv;
  double *delay_state_delayed_lambda_v_s_Sv;
  double Ev_r0;
  double Ev_s0;
  double ft;
  double init_res;
  double initial_A_r;
  double initial_A_s;
  double initial_D_r;
  double initial_D_s;
  double initial_Ev_r;
  double initial_Ev_s;
  double initial_Iv_r;
  double initial_Iv_s;
  double initial_S;
  double initial_Sv;
  double initial_t;
  double initial_T_r;
  double initial_T_s;
  double Iv_r0;
  double Iv_s0;
  double m;
  double mu;
  double n;
  double phi;
  double rA;
  double rD;
  double res_time;
  double resistance_dur_mult;
  double resistance_trans_mult;
  double rT_r_true;
  double rT_s;
  double S0;
  double Sv0;
  double T_r0;
  double T_s0;
  double toff;
  double ton;
  bool model_sr_use_dde;
} model_sr_internal;
typedef struct model_internal {
  double a;
  double A_r0;
  double A_s0;
  double b;
  double cA;
  double cD;
  double cT;
  double D_r0;
  double D_s0;
  int *delay_index_delayed_lambda_v_r_Sv;
  int *delay_index_delayed_lambda_v_s_Sv;
  double *delay_state_delayed_lambda_v_r_Sv;
  double *delay_state_delayed_lambda_v_s_Sv;
  double Ev_r0;
  double Ev_s0;
  double ft;
  double init_res;
  double initial_A_r;
  double initial_A_s;
  double initial_D_r;
  double initial_D_s;
  double initial_Ev_r;
  double initial_Ev_s;
  double initial_Iv_r;
  double initial_Iv_s;
  double initial_S;
  double initial_Sv;
  double initial_t;
  double initial_T_r;
  double initial_T_s;
  double Iv_r0;
  double Iv_s0;
  double m;
  double mu;
  double n;
  double phi;
  double rA;
  double rD;
  double res_time;
  double resistance_dur_mult;
  double resistance_trans_mult;
  double rT_r_true;
  double rT_s;
  double S0;
  double Sv0;
  double T_r0;
  double T_s0;
  double toff;
  double ton;
  bool model_use_dde;
} model_internal;
model_sr_internal* model_sr_get_internal(SEXP internal_p, int closed_error);
static void model_sr_finalise(SEXP internal_p);
SEXP model_sr_create(SEXP user);
void model_sr_initmod_desolve(void(* odeparms) (int *, double *));
SEXP model_sr_contents(SEXP internal_p);
SEXP model_sr_set_user(SEXP internal_p, SEXP user);
SEXP model_sr_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP model_sr_use_dde_ptr);
SEXP model_sr_metadata(SEXP internal_p);
SEXP model_sr_initial_conditions(SEXP internal_p, SEXP t_ptr);
void model_sr_rhs(model_sr_internal* internal, double t, double * state, double * dstatedt, double * output);
void model_sr_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void model_sr_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
void model_sr_output_dde(size_t n_eq, double t, double * state, size_t n_output, double * output, void * internal_p);
SEXP model_sr_rhs_r(SEXP internal_p, SEXP t, SEXP state);
model_internal* model_get_internal(SEXP internal_p, int closed_error);
static void model_finalise(SEXP internal_p);
SEXP model_create(SEXP user);
void model_initmod_desolve(void(* odeparms) (int *, double *));
SEXP model_contents(SEXP internal_p);
SEXP model_set_user(SEXP internal_p, SEXP user);
SEXP model_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP model_use_dde_ptr);
SEXP model_metadata(SEXP internal_p);
SEXP model_initial_conditions(SEXP internal_p, SEXP t_ptr);
void model_rhs(model_internal* internal, double t, double * state, double * dstatedt, double * output);
void model_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal);
void model_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np);
void model_output_dde(size_t n_eq, double t, double * state, size_t n_output, double * output, void * internal_p);
SEXP model_rhs_r(SEXP internal_p, SEXP t, SEXP state);
double user_get_scalar_double(SEXP user, const char *name,
                              double default_value, double min, double max);
int user_get_scalar_int(SEXP user, const char *name,
                        int default_value, double min, double max);
void user_check_values_double(double * value, size_t len,
                                  double min, double max, const char *name);
void user_check_values_int(int * value, size_t len,
                               double min, double max, const char *name);
void user_check_values(SEXP value, double min, double max,
                           const char *name);
SEXP user_list_element(SEXP list, const char *name);
void lagvalue(double t, bool use_dde, int *idx, int dim_idx, double *state);
void lagvalue_dde(double t, int *idx, size_t dim_idx, double *state);
void lagvalue_ds(double t, int *idx, int dim_idx, double *state);
double scalar_real(SEXP x, const char * name);
model_sr_internal* model_sr_get_internal(SEXP internal_p, int closed_error) {
  model_sr_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (model_sr_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void model_sr_finalise(SEXP internal_p) {
  model_sr_internal *internal = model_sr_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal->delay_index_delayed_lambda_v_r_Sv);
    R_Free(internal->delay_index_delayed_lambda_v_s_Sv);
    R_Free(internal->delay_state_delayed_lambda_v_r_Sv);
    R_Free(internal->delay_state_delayed_lambda_v_s_Sv);
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP model_sr_create(SEXP user) {
  model_sr_internal *internal = (model_sr_internal*) R_Calloc(1, model_sr_internal);
  internal->delay_index_delayed_lambda_v_r_Sv = NULL;
  internal->delay_index_delayed_lambda_v_s_Sv = NULL;
  internal->delay_state_delayed_lambda_v_r_Sv = NULL;
  internal->delay_state_delayed_lambda_v_s_Sv = NULL;
  R_Free(internal->delay_index_delayed_lambda_v_r_Sv);
  internal->delay_index_delayed_lambda_v_r_Sv = R_Calloc(4, int);
  R_Free(internal->delay_state_delayed_lambda_v_r_Sv);
  internal->delay_state_delayed_lambda_v_r_Sv = R_Calloc(4, double);
  internal->delay_index_delayed_lambda_v_r_Sv[0] = 4;
  internal->delay_index_delayed_lambda_v_r_Sv[1] = 5;
  internal->delay_index_delayed_lambda_v_r_Sv[2] = 6;
  internal->delay_index_delayed_lambda_v_r_Sv[3] = 7;
  R_Free(internal->delay_index_delayed_lambda_v_s_Sv);
  internal->delay_index_delayed_lambda_v_s_Sv = R_Calloc(4, int);
  R_Free(internal->delay_state_delayed_lambda_v_s_Sv);
  internal->delay_state_delayed_lambda_v_s_Sv = R_Calloc(4, double);
  internal->delay_index_delayed_lambda_v_s_Sv[0] = 1;
  internal->delay_index_delayed_lambda_v_s_Sv[1] = 2;
  internal->delay_index_delayed_lambda_v_s_Sv[2] = 3;
  internal->delay_index_delayed_lambda_v_s_Sv[3] = 7;
  internal->a = NA_REAL;
  internal->A_r0 = NA_REAL;
  internal->A_s0 = NA_REAL;
  internal->b = NA_REAL;
  internal->cA = NA_REAL;
  internal->cD = NA_REAL;
  internal->cT = NA_REAL;
  internal->D_r0 = NA_REAL;
  internal->D_s0 = NA_REAL;
  internal->Ev_r0 = NA_REAL;
  internal->Ev_s0 = NA_REAL;
  internal->ft = NA_REAL;
  internal->init_res = NA_REAL;
  internal->Iv_r0 = NA_REAL;
  internal->Iv_s0 = NA_REAL;
  internal->m = NA_REAL;
  internal->mu = NA_REAL;
  internal->n = NA_REAL;
  internal->phi = NA_REAL;
  internal->rA = NA_REAL;
  internal->rD = NA_REAL;
  internal->res_time = NA_REAL;
  internal->resistance_dur_mult = NA_REAL;
  internal->resistance_trans_mult = NA_REAL;
  internal->rT_r_true = NA_REAL;
  internal->rT_s = NA_REAL;
  internal->S0 = NA_REAL;
  internal->Sv0 = NA_REAL;
  internal->T_r0 = NA_REAL;
  internal->T_s0 = NA_REAL;
  internal->toff = NA_REAL;
  internal->ton = NA_REAL;
  internal->initial_t = NA_REAL;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, model_sr_finalise);
  UNPROTECT(1);
  return ptr;
}
static model_sr_internal *model_sr_internal_ds;
void model_sr_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  model_sr_internal_ds = model_sr_get_internal(get_desolve_gparms(), 1);
}
SEXP model_sr_contents(SEXP internal_p) {
  model_sr_internal *internal = model_sr_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 50));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->a));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->A_r0));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->A_s0));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->b));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->cA));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->cD));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->cT));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->D_r0));
  SET_VECTOR_ELT(contents, 8, ScalarReal(internal->D_s0));
  SEXP delay_index_delayed_lambda_v_r_Sv = PROTECT(allocVector(INTSXP, 4));
  memcpy(INTEGER(delay_index_delayed_lambda_v_r_Sv), internal->delay_index_delayed_lambda_v_r_Sv, 4 * sizeof(int));
  SET_VECTOR_ELT(contents, 9, delay_index_delayed_lambda_v_r_Sv);
  SEXP delay_index_delayed_lambda_v_s_Sv = PROTECT(allocVector(INTSXP, 4));
  memcpy(INTEGER(delay_index_delayed_lambda_v_s_Sv), internal->delay_index_delayed_lambda_v_s_Sv, 4 * sizeof(int));
  SET_VECTOR_ELT(contents, 10, delay_index_delayed_lambda_v_s_Sv);
  SEXP delay_state_delayed_lambda_v_r_Sv = PROTECT(allocVector(REALSXP, 4));
  memcpy(REAL(delay_state_delayed_lambda_v_r_Sv), internal->delay_state_delayed_lambda_v_r_Sv, 4 * sizeof(double));
  SET_VECTOR_ELT(contents, 11, delay_state_delayed_lambda_v_r_Sv);
  SEXP delay_state_delayed_lambda_v_s_Sv = PROTECT(allocVector(REALSXP, 4));
  memcpy(REAL(delay_state_delayed_lambda_v_s_Sv), internal->delay_state_delayed_lambda_v_s_Sv, 4 * sizeof(double));
  SET_VECTOR_ELT(contents, 12, delay_state_delayed_lambda_v_s_Sv);
  SET_VECTOR_ELT(contents, 13, ScalarReal(internal->Ev_r0));
  SET_VECTOR_ELT(contents, 14, ScalarReal(internal->Ev_s0));
  SET_VECTOR_ELT(contents, 15, ScalarReal(internal->ft));
  SET_VECTOR_ELT(contents, 16, ScalarReal(internal->init_res));
  SET_VECTOR_ELT(contents, 17, ScalarReal(internal->initial_A_r));
  SET_VECTOR_ELT(contents, 18, ScalarReal(internal->initial_A_s));
  SET_VECTOR_ELT(contents, 19, ScalarReal(internal->initial_D_r));
  SET_VECTOR_ELT(contents, 20, ScalarReal(internal->initial_D_s));
  SET_VECTOR_ELT(contents, 21, ScalarReal(internal->initial_Ev_r));
  SET_VECTOR_ELT(contents, 22, ScalarReal(internal->initial_Ev_s));
  SET_VECTOR_ELT(contents, 23, ScalarReal(internal->initial_Iv_r));
  SET_VECTOR_ELT(contents, 24, ScalarReal(internal->initial_Iv_s));
  SET_VECTOR_ELT(contents, 25, ScalarReal(internal->initial_S));
  SET_VECTOR_ELT(contents, 26, ScalarReal(internal->initial_Sv));
  SET_VECTOR_ELT(contents, 27, ScalarReal(internal->initial_t));
  SET_VECTOR_ELT(contents, 28, ScalarReal(internal->initial_T_r));
  SET_VECTOR_ELT(contents, 29, ScalarReal(internal->initial_T_s));
  SET_VECTOR_ELT(contents, 30, ScalarReal(internal->Iv_r0));
  SET_VECTOR_ELT(contents, 31, ScalarReal(internal->Iv_s0));
  SET_VECTOR_ELT(contents, 32, ScalarReal(internal->m));
  SET_VECTOR_ELT(contents, 33, ScalarReal(internal->mu));
  SET_VECTOR_ELT(contents, 34, ScalarReal(internal->n));
  SET_VECTOR_ELT(contents, 35, ScalarReal(internal->phi));
  SET_VECTOR_ELT(contents, 36, ScalarReal(internal->rA));
  SET_VECTOR_ELT(contents, 37, ScalarReal(internal->rD));
  SET_VECTOR_ELT(contents, 38, ScalarReal(internal->res_time));
  SET_VECTOR_ELT(contents, 39, ScalarReal(internal->resistance_dur_mult));
  SET_VECTOR_ELT(contents, 40, ScalarReal(internal->resistance_trans_mult));
  SET_VECTOR_ELT(contents, 41, ScalarReal(internal->rT_r_true));
  SET_VECTOR_ELT(contents, 42, ScalarReal(internal->rT_s));
  SET_VECTOR_ELT(contents, 43, ScalarReal(internal->S0));
  SET_VECTOR_ELT(contents, 44, ScalarReal(internal->Sv0));
  SET_VECTOR_ELT(contents, 45, ScalarReal(internal->T_r0));
  SET_VECTOR_ELT(contents, 46, ScalarReal(internal->T_s0));
  SET_VECTOR_ELT(contents, 47, ScalarReal(internal->toff));
  SET_VECTOR_ELT(contents, 48, ScalarReal(internal->ton));
  SET_VECTOR_ELT(contents, 49, ScalarLogical(internal->model_sr_use_dde));
  SEXP nms = PROTECT(allocVector(STRSXP, 50));
  SET_STRING_ELT(nms, 0, mkChar("a"));
  SET_STRING_ELT(nms, 1, mkChar("A_r0"));
  SET_STRING_ELT(nms, 2, mkChar("A_s0"));
  SET_STRING_ELT(nms, 3, mkChar("b"));
  SET_STRING_ELT(nms, 4, mkChar("cA"));
  SET_STRING_ELT(nms, 5, mkChar("cD"));
  SET_STRING_ELT(nms, 6, mkChar("cT"));
  SET_STRING_ELT(nms, 7, mkChar("D_r0"));
  SET_STRING_ELT(nms, 8, mkChar("D_s0"));
  SET_STRING_ELT(nms, 9, mkChar("delay_index_delayed_lambda_v_r_Sv"));
  SET_STRING_ELT(nms, 10, mkChar("delay_index_delayed_lambda_v_s_Sv"));
  SET_STRING_ELT(nms, 11, mkChar("delay_state_delayed_lambda_v_r_Sv"));
  SET_STRING_ELT(nms, 12, mkChar("delay_state_delayed_lambda_v_s_Sv"));
  SET_STRING_ELT(nms, 13, mkChar("Ev_r0"));
  SET_STRING_ELT(nms, 14, mkChar("Ev_s0"));
  SET_STRING_ELT(nms, 15, mkChar("ft"));
  SET_STRING_ELT(nms, 16, mkChar("init_res"));
  SET_STRING_ELT(nms, 17, mkChar("initial_A_r"));
  SET_STRING_ELT(nms, 18, mkChar("initial_A_s"));
  SET_STRING_ELT(nms, 19, mkChar("initial_D_r"));
  SET_STRING_ELT(nms, 20, mkChar("initial_D_s"));
  SET_STRING_ELT(nms, 21, mkChar("initial_Ev_r"));
  SET_STRING_ELT(nms, 22, mkChar("initial_Ev_s"));
  SET_STRING_ELT(nms, 23, mkChar("initial_Iv_r"));
  SET_STRING_ELT(nms, 24, mkChar("initial_Iv_s"));
  SET_STRING_ELT(nms, 25, mkChar("initial_S"));
  SET_STRING_ELT(nms, 26, mkChar("initial_Sv"));
  SET_STRING_ELT(nms, 27, mkChar("initial_t"));
  SET_STRING_ELT(nms, 28, mkChar("initial_T_r"));
  SET_STRING_ELT(nms, 29, mkChar("initial_T_s"));
  SET_STRING_ELT(nms, 30, mkChar("Iv_r0"));
  SET_STRING_ELT(nms, 31, mkChar("Iv_s0"));
  SET_STRING_ELT(nms, 32, mkChar("m"));
  SET_STRING_ELT(nms, 33, mkChar("mu"));
  SET_STRING_ELT(nms, 34, mkChar("n"));
  SET_STRING_ELT(nms, 35, mkChar("phi"));
  SET_STRING_ELT(nms, 36, mkChar("rA"));
  SET_STRING_ELT(nms, 37, mkChar("rD"));
  SET_STRING_ELT(nms, 38, mkChar("res_time"));
  SET_STRING_ELT(nms, 39, mkChar("resistance_dur_mult"));
  SET_STRING_ELT(nms, 40, mkChar("resistance_trans_mult"));
  SET_STRING_ELT(nms, 41, mkChar("rT_r_true"));
  SET_STRING_ELT(nms, 42, mkChar("rT_s"));
  SET_STRING_ELT(nms, 43, mkChar("S0"));
  SET_STRING_ELT(nms, 44, mkChar("Sv0"));
  SET_STRING_ELT(nms, 45, mkChar("T_r0"));
  SET_STRING_ELT(nms, 46, mkChar("T_s0"));
  SET_STRING_ELT(nms, 47, mkChar("toff"));
  SET_STRING_ELT(nms, 48, mkChar("ton"));
  SET_STRING_ELT(nms, 49, mkChar("model_sr_use_dde"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(6);
  return contents;
}
SEXP model_sr_set_user(SEXP internal_p, SEXP user) {
  model_sr_internal *internal = model_sr_get_internal(internal_p, 1);
  internal->a = user_get_scalar_double(user, "a", internal->a, NA_REAL, NA_REAL);
  internal->A_r0 = user_get_scalar_double(user, "A_r0", internal->A_r0, NA_REAL, NA_REAL);
  internal->A_s0 = user_get_scalar_double(user, "A_s0", internal->A_s0, NA_REAL, NA_REAL);
  internal->b = user_get_scalar_double(user, "b", internal->b, NA_REAL, NA_REAL);
  internal->cA = user_get_scalar_double(user, "cA", internal->cA, NA_REAL, NA_REAL);
  internal->cD = user_get_scalar_double(user, "cD", internal->cD, NA_REAL, NA_REAL);
  internal->cT = user_get_scalar_double(user, "cT", internal->cT, NA_REAL, NA_REAL);
  internal->D_r0 = user_get_scalar_double(user, "D_r0", internal->D_r0, NA_REAL, NA_REAL);
  internal->D_s0 = user_get_scalar_double(user, "D_s0", internal->D_s0, NA_REAL, NA_REAL);
  internal->Ev_r0 = user_get_scalar_double(user, "Ev_r0", internal->Ev_r0, NA_REAL, NA_REAL);
  internal->Ev_s0 = user_get_scalar_double(user, "Ev_s0", internal->Ev_s0, NA_REAL, NA_REAL);
  internal->ft = user_get_scalar_double(user, "ft", internal->ft, NA_REAL, NA_REAL);
  internal->init_res = user_get_scalar_double(user, "init_res", internal->init_res, NA_REAL, NA_REAL);
  internal->Iv_r0 = user_get_scalar_double(user, "Iv_r0", internal->Iv_r0, NA_REAL, NA_REAL);
  internal->Iv_s0 = user_get_scalar_double(user, "Iv_s0", internal->Iv_s0, NA_REAL, NA_REAL);
  internal->m = user_get_scalar_double(user, "m", internal->m, NA_REAL, NA_REAL);
  internal->mu = user_get_scalar_double(user, "mu", internal->mu, NA_REAL, NA_REAL);
  internal->n = user_get_scalar_double(user, "n", internal->n, NA_REAL, NA_REAL);
  internal->phi = user_get_scalar_double(user, "phi", internal->phi, NA_REAL, NA_REAL);
  internal->rA = user_get_scalar_double(user, "rA", internal->rA, NA_REAL, NA_REAL);
  internal->rD = user_get_scalar_double(user, "rD", internal->rD, NA_REAL, NA_REAL);
  internal->res_time = user_get_scalar_double(user, "res_time", internal->res_time, NA_REAL, NA_REAL);
  internal->resistance_dur_mult = user_get_scalar_double(user, "resistance_dur_mult", internal->resistance_dur_mult, NA_REAL, NA_REAL);
  internal->resistance_trans_mult = user_get_scalar_double(user, "resistance_trans_mult", internal->resistance_trans_mult, NA_REAL, NA_REAL);
  internal->rT_r_true = user_get_scalar_double(user, "rT_r_true", internal->rT_r_true, NA_REAL, NA_REAL);
  internal->rT_s = user_get_scalar_double(user, "rT_s", internal->rT_s, NA_REAL, NA_REAL);
  internal->S0 = user_get_scalar_double(user, "S0", internal->S0, NA_REAL, NA_REAL);
  internal->Sv0 = user_get_scalar_double(user, "Sv0", internal->Sv0, NA_REAL, NA_REAL);
  internal->T_r0 = user_get_scalar_double(user, "T_r0", internal->T_r0, NA_REAL, NA_REAL);
  internal->T_s0 = user_get_scalar_double(user, "T_s0", internal->T_s0, NA_REAL, NA_REAL);
  internal->toff = user_get_scalar_double(user, "toff", internal->toff, NA_REAL, NA_REAL);
  internal->ton = user_get_scalar_double(user, "ton", internal->ton, NA_REAL, NA_REAL);
  internal->initial_A_r = internal->A_r0;
  internal->initial_A_s = internal->A_s0;
  internal->initial_D_r = internal->D_r0;
  internal->initial_D_s = internal->D_s0;
  internal->initial_Ev_r = internal->Ev_r0;
  internal->initial_Ev_s = internal->Ev_s0;
  internal->initial_Iv_r = internal->Iv_r0;
  internal->initial_Iv_s = internal->Iv_s0;
  internal->initial_S = internal->S0;
  internal->initial_Sv = internal->Sv0;
  internal->initial_T_r = internal->T_r0;
  internal->initial_T_s = internal->T_s0;
  return R_NilValue;
}
SEXP model_sr_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP model_sr_use_dde_ptr) {
  model_sr_internal *internal = model_sr_get_internal(internal_p, 1);
  const double t = REAL(t_ptr)[0];
  internal->initial_t = t;
  internal->model_sr_use_dde = INTEGER(model_sr_use_dde_ptr)[0];
  if (state_ptr != R_NilValue) {
    double * state = REAL(state_ptr);
    internal->initial_S = state[0];
    internal->initial_D_s = state[1];
    internal->initial_A_s = state[2];
    internal->initial_T_s = state[3];
    internal->initial_D_r = state[4];
    internal->initial_A_r = state[5];
    internal->initial_T_r = state[6];
    internal->initial_Sv = state[7];
    internal->initial_Ev_s = state[8];
    internal->initial_Iv_s = state[9];
    internal->initial_Ev_r = state[10];
    internal->initial_Iv_r = state[11];
  }
  return R_NilValue;
}
SEXP model_sr_metadata(SEXP internal_p) {
  model_sr_internal *internal = model_sr_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 12));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 12));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_VECTOR_ELT(variable_length, 2, R_NilValue);
  SET_VECTOR_ELT(variable_length, 3, R_NilValue);
  SET_VECTOR_ELT(variable_length, 4, R_NilValue);
  SET_VECTOR_ELT(variable_length, 5, R_NilValue);
  SET_VECTOR_ELT(variable_length, 6, R_NilValue);
  SET_VECTOR_ELT(variable_length, 7, R_NilValue);
  SET_VECTOR_ELT(variable_length, 8, R_NilValue);
  SET_VECTOR_ELT(variable_length, 9, R_NilValue);
  SET_VECTOR_ELT(variable_length, 10, R_NilValue);
  SET_VECTOR_ELT(variable_length, 11, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("S"));
  SET_STRING_ELT(variable_names, 1, mkChar("D_s"));
  SET_STRING_ELT(variable_names, 2, mkChar("A_s"));
  SET_STRING_ELT(variable_names, 3, mkChar("T_s"));
  SET_STRING_ELT(variable_names, 4, mkChar("D_r"));
  SET_STRING_ELT(variable_names, 5, mkChar("A_r"));
  SET_STRING_ELT(variable_names, 6, mkChar("T_r"));
  SET_STRING_ELT(variable_names, 7, mkChar("Sv"));
  SET_STRING_ELT(variable_names, 8, mkChar("Ev_s"));
  SET_STRING_ELT(variable_names, 9, mkChar("Iv_s"));
  SET_STRING_ELT(variable_names, 10, mkChar("Ev_r"));
  SET_STRING_ELT(variable_names, 11, mkChar("Iv_r"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SEXP output_length = PROTECT(allocVector(VECSXP, 9));
  SEXP output_names = PROTECT(allocVector(STRSXP, 9));
  setAttrib(output_length, R_NamesSymbol, output_names);
  SET_VECTOR_ELT(output_length, 0, R_NilValue);
  SET_VECTOR_ELT(output_length, 1, R_NilValue);
  SET_VECTOR_ELT(output_length, 2, R_NilValue);
  SET_VECTOR_ELT(output_length, 3, R_NilValue);
  SET_VECTOR_ELT(output_length, 4, R_NilValue);
  SET_VECTOR_ELT(output_length, 5, R_NilValue);
  SET_VECTOR_ELT(output_length, 6, R_NilValue);
  SET_VECTOR_ELT(output_length, 7, R_NilValue);
  SET_VECTOR_ELT(output_length, 8, R_NilValue);
  SET_STRING_ELT(output_names, 0, mkChar("prevalence"));
  SET_STRING_ELT(output_names, 1, mkChar("prevalence_res"));
  SET_STRING_ELT(output_names, 2, mkChar("population"));
  SET_STRING_ELT(output_names, 3, mkChar("population_v"));
  SET_STRING_ELT(output_names, 4, mkChar("prevalence_sensitive"));
  SET_STRING_ELT(output_names, 5, mkChar("EIR_s"));
  SET_STRING_ELT(output_names, 6, mkChar("EIR_r"));
  SET_STRING_ELT(output_names, 7, mkChar("EIR_global"));
  SET_STRING_ELT(output_names, 8, mkChar("invading_A_r_out"));
  SET_VECTOR_ELT(ret, 1, output_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(9));
  UNPROTECT(2);
  return ret;
}
SEXP model_sr_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  double t = scalar_real(t_ptr, "t");
  model_sr_internal *internal = model_sr_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 12));
  double * state = REAL(r_state);
  state[0] = internal->initial_S;
  state[1] = internal->initial_D_s;
  state[2] = internal->initial_A_s;
  state[3] = internal->initial_T_s;
  state[4] = internal->initial_D_r;
  state[5] = internal->initial_A_r;
  state[6] = internal->initial_T_r;
  state[7] = internal->initial_Sv;
  state[8] = internal->initial_Ev_s;
  state[9] = internal->initial_Iv_s;
  state[10] = internal->initial_Ev_r;
  state[11] = internal->initial_Iv_r;
  UNPROTECT(1);
  return r_state;
}
void model_sr_rhs(model_sr_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double S = state[0];
  double D_s = state[1];
  double A_s = state[2];
  double T_s = state[3];
  double D_r = state[4];
  double A_r = state[5];
  double T_r = state[6];
  double Sv = state[7];
  double Ev_s = state[8];
  double Iv_s = state[9];
  double Ev_r = state[10];
  double Iv_r = state[11];
  // delay block for delayed_lambda_v_r_Sv
  double delayed_lambda_v_r_Sv;
  {
    const double t_true = t;
    const double t = t_true - internal->n;
    double D_r;
    double A_r;
    double T_r;
    double Sv;
    if (t <= internal->initial_t) {
      D_r = internal->initial_D_r;
      A_r = internal->initial_A_r;
      T_r = internal->initial_T_r;
      Sv = internal->initial_Sv;
    } else {
      lagvalue(t, internal->model_sr_use_dde, internal->delay_index_delayed_lambda_v_r_Sv, 4, internal->delay_state_delayed_lambda_v_r_Sv);
      D_r = internal->delay_state_delayed_lambda_v_r_Sv[0];
      A_r = internal->delay_state_delayed_lambda_v_r_Sv[1];
      T_r = internal->delay_state_delayed_lambda_v_r_Sv[2];
      Sv = internal->delay_state_delayed_lambda_v_r_Sv[3];
    }
    double lambda_v_r = internal->a * (internal->cA * A_r + internal->cD * D_r + internal->cT * T_r * internal->resistance_trans_mult);
    delayed_lambda_v_r_Sv = lambda_v_r * Sv * exp(-(internal->mu) * internal->n);
  }
  // delay block for delayed_lambda_v_s_Sv
  double delayed_lambda_v_s_Sv;
  {
    const double t_true = t;
    const double t = t_true - internal->n;
    double D_s;
    double A_s;
    double T_s;
    double Sv;
    if (t <= internal->initial_t) {
      D_s = internal->initial_D_s;
      A_s = internal->initial_A_s;
      T_s = internal->initial_T_s;
      Sv = internal->initial_Sv;
    } else {
      lagvalue(t, internal->model_sr_use_dde, internal->delay_index_delayed_lambda_v_s_Sv, 4, internal->delay_state_delayed_lambda_v_s_Sv);
      D_s = internal->delay_state_delayed_lambda_v_s_Sv[0];
      A_s = internal->delay_state_delayed_lambda_v_s_Sv[1];
      T_s = internal->delay_state_delayed_lambda_v_s_Sv[2];
      Sv = internal->delay_state_delayed_lambda_v_s_Sv[3];
    }
    double lambda_v_s = internal->a * (internal->cA * A_s + internal->cD * D_s + internal->cT * T_s);
    delayed_lambda_v_s_Sv = lambda_v_s * Sv * exp(-(internal->mu) * internal->n);
  }
  double invading_A_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : A_s * log(1 / (double) (1 - internal->init_res)));
  double invading_D_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : D_s * log(1 / (double) (1 - internal->init_res)));
  double invading_Ev_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : Ev_s * log(1 / (double) (1 - internal->init_res)));
  double invading_Iv_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : Iv_s * log(1 / (double) (1 - internal->init_res)));
  double invading_T_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : T_s * log(1 / (double) (1 - internal->init_res)));
  double lambda_r = internal->m * internal->a * internal->b * Iv_r;
  double lambda_s = internal->m * internal->a * internal->b * Iv_s;
  double lambda_v_r = internal->a * (internal->cA * A_r + internal->cD * D_r + internal->cT * T_r * internal->resistance_trans_mult);
  double lambda_v_s = internal->a * (internal->cA * A_s + internal->cD * D_s + internal->cT * T_s);
  double rT_r = ((t > internal->ton && t < internal->toff ? internal->rT_r_true / (double) internal->resistance_dur_mult : internal->rT_s));
  dstatedt[5] = invading_A_r + (S * lambda_r * (1 - internal->phi) + lambda_r * A_s * (1 - internal->phi) + D_r * internal->rD - lambda_r * A_r * internal->phi * (1 - internal->ft) - lambda_r * A_r * internal->phi * internal->ft - lambda_s * A_r * internal->phi * (1 - internal->ft) - lambda_s * A_r * internal->phi * internal->ft - lambda_s * A_r * (1 - internal->phi) - A_r * internal->rA);
  dstatedt[2] = (S * lambda_s * (1 - internal->phi) + lambda_s * A_r * (1 - internal->phi) + D_s * internal->rD - lambda_s * A_s * internal->phi * (1 - internal->ft) - lambda_s * A_s * internal->phi * internal->ft - lambda_r * A_s * internal->phi * (1 - internal->ft) - lambda_r * A_s * internal->phi * internal->ft - lambda_r * A_s * (1 - internal->phi) - A_s * internal->rA - invading_A_r);
  dstatedt[4] = invading_D_r + (S * lambda_r * internal->phi * (1 - internal->ft) + lambda_r * A_s * internal->phi * (1 - internal->ft) + lambda_r * A_r * internal->phi * (1 - internal->ft) - D_r * internal->rD);
  dstatedt[1] = (S * lambda_s * internal->phi * (1 - internal->ft) + lambda_s * A_r * internal->phi * (1 - internal->ft) + lambda_s * A_s * internal->phi * (1 - internal->ft) - D_s * internal->rD) - invading_D_r;
  dstatedt[10] = invading_Ev_r + (lambda_v_r * Sv - delayed_lambda_v_r_Sv - internal->mu * Ev_r);
  dstatedt[8] = lambda_v_s * Sv - delayed_lambda_v_s_Sv - internal->mu * Ev_s - invading_Ev_r;
  dstatedt[11] = invading_Iv_r + (delayed_lambda_v_r_Sv - internal->mu * Iv_r);
  dstatedt[9] = delayed_lambda_v_s_Sv - internal->mu * Iv_s - invading_Iv_r;
  dstatedt[0] = (-(S) * lambda_s * (internal->phi * internal->ft + internal->phi * (1 - internal->ft) + (1 - internal->phi)) - S * lambda_r * (internal->phi * internal->ft + internal->phi * (1 - internal->ft) + (1 - internal->phi)) + T_s * internal->rT_s + A_s * internal->rA + A_r * internal->rA + T_r * rT_r);
  dstatedt[7] = internal->mu - (lambda_v_s + lambda_v_r) * Sv - internal->mu * Sv;
  dstatedt[6] = invading_T_r + (S * lambda_r * internal->phi * internal->ft + lambda_r * A_r * internal->phi * internal->ft + lambda_r * A_s * internal->phi * internal->ft - T_r * rT_r);
  dstatedt[3] = (S * lambda_s * internal->phi * internal->ft + lambda_s * A_r * internal->phi * internal->ft + lambda_s * A_s * internal->phi * internal->ft - T_s * internal->rT_s) - invading_T_r;
  if (output) {
    double EIR_r = internal->m * internal->a * Iv_r * 365;
    double EIR_s = internal->m * internal->a * Iv_s * 365;
    output[2] = S + D_s + A_s + T_s + D_r + A_r + T_r;
    output[3] = Sv + Ev_s + Iv_s + Ev_r + Iv_r;
    output[0] = A_s + D_s + T_s + A_r + D_r + T_r;
    output[1] = (A_r + D_r + T_r) / (double) (A_s + D_s + T_s + A_r + D_r + T_r);
    output[4] = A_s + D_s + T_s;
    double EIR_global = EIR_s + EIR_r;
    output[6] = EIR_r;
    output[5] = EIR_s;
    output[8] = invading_A_r;
    output[7] = EIR_global;
  }
}
void model_sr_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  model_sr_rhs((model_sr_internal*)internal, t, state, dstatedt, NULL);
}
void model_sr_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  model_sr_rhs(model_sr_internal_ds, *t, state, dstatedt, output);
}
void model_sr_output_dde(size_t n_eq, double t, double * state, size_t n_output, double * output, void * internal_p) {
  model_sr_internal *internal = (model_sr_internal*) internal_p;
  double S = state[0];
  double D_s = state[1];
  double A_s = state[2];
  double T_s = state[3];
  double D_r = state[4];
  double A_r = state[5];
  double T_r = state[6];
  double Sv = state[7];
  double Ev_s = state[8];
  double Iv_s = state[9];
  double Ev_r = state[10];
  double Iv_r = state[11];
  double EIR_r = internal->m * internal->a * Iv_r * 365;
  double EIR_s = internal->m * internal->a * Iv_s * 365;
  double invading_A_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : A_s * log(1 / (double) (1 - internal->init_res)));
  output[2] = S + D_s + A_s + T_s + D_r + A_r + T_r;
  output[3] = Sv + Ev_s + Iv_s + Ev_r + Iv_r;
  output[0] = A_s + D_s + T_s + A_r + D_r + T_r;
  output[1] = (A_r + D_r + T_r) / (double) (A_s + D_s + T_s + A_r + D_r + T_r);
  output[4] = A_s + D_s + T_s;
  double EIR_global = EIR_s + EIR_r;
  output[6] = EIR_r;
  output[5] = EIR_s;
  output[8] = invading_A_r;
  output[7] = EIR_global;
}
SEXP model_sr_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  model_sr_internal *internal = model_sr_get_internal(internal_p, 1);
  SEXP output_ptr = PROTECT(allocVector(REALSXP, 9));
  setAttrib(dstatedt, install("output"), output_ptr);
  UNPROTECT(1);
  double *output = REAL(output_ptr);
  const double initial_t = internal->initial_t;
  if (ISNA(initial_t)) {
    internal->initial_t = scalar_real(t, "t");
  }
  model_sr_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  if (ISNA(initial_t)) {
    internal->initial_t = initial_t;
  }
  UNPROTECT(1);
  return dstatedt;
}
model_internal* model_get_internal(SEXP internal_p, int closed_error) {
  model_internal *internal = NULL;
  if (TYPEOF(internal_p) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  internal = (model_internal*) R_ExternalPtrAddr(internal_p);
  if (!internal && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return internal;
}
void model_finalise(SEXP internal_p) {
  model_internal *internal = model_get_internal(internal_p, 0);
  if (internal_p) {
    R_Free(internal->delay_index_delayed_lambda_v_r_Sv);
    R_Free(internal->delay_index_delayed_lambda_v_s_Sv);
    R_Free(internal->delay_state_delayed_lambda_v_r_Sv);
    R_Free(internal->delay_state_delayed_lambda_v_s_Sv);
    R_Free(internal);
    R_ClearExternalPtr(internal_p);
  }
}
SEXP model_create(SEXP user) {
  model_internal *internal = (model_internal*) R_Calloc(1, model_internal);
  internal->delay_index_delayed_lambda_v_r_Sv = NULL;
  internal->delay_index_delayed_lambda_v_s_Sv = NULL;
  internal->delay_state_delayed_lambda_v_r_Sv = NULL;
  internal->delay_state_delayed_lambda_v_s_Sv = NULL;
  R_Free(internal->delay_index_delayed_lambda_v_r_Sv);
  internal->delay_index_delayed_lambda_v_r_Sv = R_Calloc(4, int);
  R_Free(internal->delay_state_delayed_lambda_v_r_Sv);
  internal->delay_state_delayed_lambda_v_r_Sv = R_Calloc(4, double);
  internal->delay_index_delayed_lambda_v_r_Sv[0] = 4;
  internal->delay_index_delayed_lambda_v_r_Sv[1] = 5;
  internal->delay_index_delayed_lambda_v_r_Sv[2] = 6;
  internal->delay_index_delayed_lambda_v_r_Sv[3] = 7;
  R_Free(internal->delay_index_delayed_lambda_v_s_Sv);
  internal->delay_index_delayed_lambda_v_s_Sv = R_Calloc(4, int);
  R_Free(internal->delay_state_delayed_lambda_v_s_Sv);
  internal->delay_state_delayed_lambda_v_s_Sv = R_Calloc(4, double);
  internal->delay_index_delayed_lambda_v_s_Sv[0] = 1;
  internal->delay_index_delayed_lambda_v_s_Sv[1] = 2;
  internal->delay_index_delayed_lambda_v_s_Sv[2] = 3;
  internal->delay_index_delayed_lambda_v_s_Sv[3] = 7;
  internal->a = NA_REAL;
  internal->A_r0 = NA_REAL;
  internal->A_s0 = NA_REAL;
  internal->b = NA_REAL;
  internal->cA = NA_REAL;
  internal->cD = NA_REAL;
  internal->cT = NA_REAL;
  internal->D_r0 = NA_REAL;
  internal->D_s0 = NA_REAL;
  internal->Ev_r0 = NA_REAL;
  internal->Ev_s0 = NA_REAL;
  internal->ft = NA_REAL;
  internal->init_res = NA_REAL;
  internal->Iv_r0 = NA_REAL;
  internal->Iv_s0 = NA_REAL;
  internal->m = NA_REAL;
  internal->mu = NA_REAL;
  internal->n = NA_REAL;
  internal->phi = NA_REAL;
  internal->rA = NA_REAL;
  internal->rD = NA_REAL;
  internal->res_time = NA_REAL;
  internal->resistance_dur_mult = NA_REAL;
  internal->resistance_trans_mult = NA_REAL;
  internal->rT_r_true = NA_REAL;
  internal->rT_s = NA_REAL;
  internal->S0 = NA_REAL;
  internal->Sv0 = NA_REAL;
  internal->T_r0 = NA_REAL;
  internal->T_s0 = NA_REAL;
  internal->toff = NA_REAL;
  internal->ton = NA_REAL;
  internal->initial_t = NA_REAL;
  SEXP ptr = PROTECT(R_MakeExternalPtr(internal, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(ptr, model_finalise);
  UNPROTECT(1);
  return ptr;
}
static model_internal *model_internal_ds;
void model_initmod_desolve(void(* odeparms) (int *, double *)) {
  static DL_FUNC get_desolve_gparms = NULL;
  if (get_desolve_gparms == NULL) {
    get_desolve_gparms =
      R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  model_internal_ds = model_get_internal(get_desolve_gparms(), 1);
}
SEXP model_contents(SEXP internal_p) {
  model_internal *internal = model_get_internal(internal_p, 1);
  SEXP contents = PROTECT(allocVector(VECSXP, 50));
  SET_VECTOR_ELT(contents, 0, ScalarReal(internal->a));
  SET_VECTOR_ELT(contents, 1, ScalarReal(internal->A_r0));
  SET_VECTOR_ELT(contents, 2, ScalarReal(internal->A_s0));
  SET_VECTOR_ELT(contents, 3, ScalarReal(internal->b));
  SET_VECTOR_ELT(contents, 4, ScalarReal(internal->cA));
  SET_VECTOR_ELT(contents, 5, ScalarReal(internal->cD));
  SET_VECTOR_ELT(contents, 6, ScalarReal(internal->cT));
  SET_VECTOR_ELT(contents, 7, ScalarReal(internal->D_r0));
  SET_VECTOR_ELT(contents, 8, ScalarReal(internal->D_s0));
  SEXP delay_index_delayed_lambda_v_r_Sv = PROTECT(allocVector(INTSXP, 4));
  memcpy(INTEGER(delay_index_delayed_lambda_v_r_Sv), internal->delay_index_delayed_lambda_v_r_Sv, 4 * sizeof(int));
  SET_VECTOR_ELT(contents, 9, delay_index_delayed_lambda_v_r_Sv);
  SEXP delay_index_delayed_lambda_v_s_Sv = PROTECT(allocVector(INTSXP, 4));
  memcpy(INTEGER(delay_index_delayed_lambda_v_s_Sv), internal->delay_index_delayed_lambda_v_s_Sv, 4 * sizeof(int));
  SET_VECTOR_ELT(contents, 10, delay_index_delayed_lambda_v_s_Sv);
  SEXP delay_state_delayed_lambda_v_r_Sv = PROTECT(allocVector(REALSXP, 4));
  memcpy(REAL(delay_state_delayed_lambda_v_r_Sv), internal->delay_state_delayed_lambda_v_r_Sv, 4 * sizeof(double));
  SET_VECTOR_ELT(contents, 11, delay_state_delayed_lambda_v_r_Sv);
  SEXP delay_state_delayed_lambda_v_s_Sv = PROTECT(allocVector(REALSXP, 4));
  memcpy(REAL(delay_state_delayed_lambda_v_s_Sv), internal->delay_state_delayed_lambda_v_s_Sv, 4 * sizeof(double));
  SET_VECTOR_ELT(contents, 12, delay_state_delayed_lambda_v_s_Sv);
  SET_VECTOR_ELT(contents, 13, ScalarReal(internal->Ev_r0));
  SET_VECTOR_ELT(contents, 14, ScalarReal(internal->Ev_s0));
  SET_VECTOR_ELT(contents, 15, ScalarReal(internal->ft));
  SET_VECTOR_ELT(contents, 16, ScalarReal(internal->init_res));
  SET_VECTOR_ELT(contents, 17, ScalarReal(internal->initial_A_r));
  SET_VECTOR_ELT(contents, 18, ScalarReal(internal->initial_A_s));
  SET_VECTOR_ELT(contents, 19, ScalarReal(internal->initial_D_r));
  SET_VECTOR_ELT(contents, 20, ScalarReal(internal->initial_D_s));
  SET_VECTOR_ELT(contents, 21, ScalarReal(internal->initial_Ev_r));
  SET_VECTOR_ELT(contents, 22, ScalarReal(internal->initial_Ev_s));
  SET_VECTOR_ELT(contents, 23, ScalarReal(internal->initial_Iv_r));
  SET_VECTOR_ELT(contents, 24, ScalarReal(internal->initial_Iv_s));
  SET_VECTOR_ELT(contents, 25, ScalarReal(internal->initial_S));
  SET_VECTOR_ELT(contents, 26, ScalarReal(internal->initial_Sv));
  SET_VECTOR_ELT(contents, 27, ScalarReal(internal->initial_t));
  SET_VECTOR_ELT(contents, 28, ScalarReal(internal->initial_T_r));
  SET_VECTOR_ELT(contents, 29, ScalarReal(internal->initial_T_s));
  SET_VECTOR_ELT(contents, 30, ScalarReal(internal->Iv_r0));
  SET_VECTOR_ELT(contents, 31, ScalarReal(internal->Iv_s0));
  SET_VECTOR_ELT(contents, 32, ScalarReal(internal->m));
  SET_VECTOR_ELT(contents, 33, ScalarReal(internal->mu));
  SET_VECTOR_ELT(contents, 34, ScalarReal(internal->n));
  SET_VECTOR_ELT(contents, 35, ScalarReal(internal->phi));
  SET_VECTOR_ELT(contents, 36, ScalarReal(internal->rA));
  SET_VECTOR_ELT(contents, 37, ScalarReal(internal->rD));
  SET_VECTOR_ELT(contents, 38, ScalarReal(internal->res_time));
  SET_VECTOR_ELT(contents, 39, ScalarReal(internal->resistance_dur_mult));
  SET_VECTOR_ELT(contents, 40, ScalarReal(internal->resistance_trans_mult));
  SET_VECTOR_ELT(contents, 41, ScalarReal(internal->rT_r_true));
  SET_VECTOR_ELT(contents, 42, ScalarReal(internal->rT_s));
  SET_VECTOR_ELT(contents, 43, ScalarReal(internal->S0));
  SET_VECTOR_ELT(contents, 44, ScalarReal(internal->Sv0));
  SET_VECTOR_ELT(contents, 45, ScalarReal(internal->T_r0));
  SET_VECTOR_ELT(contents, 46, ScalarReal(internal->T_s0));
  SET_VECTOR_ELT(contents, 47, ScalarReal(internal->toff));
  SET_VECTOR_ELT(contents, 48, ScalarReal(internal->ton));
  SET_VECTOR_ELT(contents, 49, ScalarLogical(internal->model_use_dde));
  SEXP nms = PROTECT(allocVector(STRSXP, 50));
  SET_STRING_ELT(nms, 0, mkChar("a"));
  SET_STRING_ELT(nms, 1, mkChar("A_r0"));
  SET_STRING_ELT(nms, 2, mkChar("A_s0"));
  SET_STRING_ELT(nms, 3, mkChar("b"));
  SET_STRING_ELT(nms, 4, mkChar("cA"));
  SET_STRING_ELT(nms, 5, mkChar("cD"));
  SET_STRING_ELT(nms, 6, mkChar("cT"));
  SET_STRING_ELT(nms, 7, mkChar("D_r0"));
  SET_STRING_ELT(nms, 8, mkChar("D_s0"));
  SET_STRING_ELT(nms, 9, mkChar("delay_index_delayed_lambda_v_r_Sv"));
  SET_STRING_ELT(nms, 10, mkChar("delay_index_delayed_lambda_v_s_Sv"));
  SET_STRING_ELT(nms, 11, mkChar("delay_state_delayed_lambda_v_r_Sv"));
  SET_STRING_ELT(nms, 12, mkChar("delay_state_delayed_lambda_v_s_Sv"));
  SET_STRING_ELT(nms, 13, mkChar("Ev_r0"));
  SET_STRING_ELT(nms, 14, mkChar("Ev_s0"));
  SET_STRING_ELT(nms, 15, mkChar("ft"));
  SET_STRING_ELT(nms, 16, mkChar("init_res"));
  SET_STRING_ELT(nms, 17, mkChar("initial_A_r"));
  SET_STRING_ELT(nms, 18, mkChar("initial_A_s"));
  SET_STRING_ELT(nms, 19, mkChar("initial_D_r"));
  SET_STRING_ELT(nms, 20, mkChar("initial_D_s"));
  SET_STRING_ELT(nms, 21, mkChar("initial_Ev_r"));
  SET_STRING_ELT(nms, 22, mkChar("initial_Ev_s"));
  SET_STRING_ELT(nms, 23, mkChar("initial_Iv_r"));
  SET_STRING_ELT(nms, 24, mkChar("initial_Iv_s"));
  SET_STRING_ELT(nms, 25, mkChar("initial_S"));
  SET_STRING_ELT(nms, 26, mkChar("initial_Sv"));
  SET_STRING_ELT(nms, 27, mkChar("initial_t"));
  SET_STRING_ELT(nms, 28, mkChar("initial_T_r"));
  SET_STRING_ELT(nms, 29, mkChar("initial_T_s"));
  SET_STRING_ELT(nms, 30, mkChar("Iv_r0"));
  SET_STRING_ELT(nms, 31, mkChar("Iv_s0"));
  SET_STRING_ELT(nms, 32, mkChar("m"));
  SET_STRING_ELT(nms, 33, mkChar("mu"));
  SET_STRING_ELT(nms, 34, mkChar("n"));
  SET_STRING_ELT(nms, 35, mkChar("phi"));
  SET_STRING_ELT(nms, 36, mkChar("rA"));
  SET_STRING_ELT(nms, 37, mkChar("rD"));
  SET_STRING_ELT(nms, 38, mkChar("res_time"));
  SET_STRING_ELT(nms, 39, mkChar("resistance_dur_mult"));
  SET_STRING_ELT(nms, 40, mkChar("resistance_trans_mult"));
  SET_STRING_ELT(nms, 41, mkChar("rT_r_true"));
  SET_STRING_ELT(nms, 42, mkChar("rT_s"));
  SET_STRING_ELT(nms, 43, mkChar("S0"));
  SET_STRING_ELT(nms, 44, mkChar("Sv0"));
  SET_STRING_ELT(nms, 45, mkChar("T_r0"));
  SET_STRING_ELT(nms, 46, mkChar("T_s0"));
  SET_STRING_ELT(nms, 47, mkChar("toff"));
  SET_STRING_ELT(nms, 48, mkChar("ton"));
  SET_STRING_ELT(nms, 49, mkChar("model_use_dde"));
  setAttrib(contents, R_NamesSymbol, nms);
  UNPROTECT(6);
  return contents;
}
SEXP model_set_user(SEXP internal_p, SEXP user) {
  model_internal *internal = model_get_internal(internal_p, 1);
  internal->a = user_get_scalar_double(user, "a", internal->a, NA_REAL, NA_REAL);
  internal->A_r0 = user_get_scalar_double(user, "A_r0", internal->A_r0, NA_REAL, NA_REAL);
  internal->A_s0 = user_get_scalar_double(user, "A_s0", internal->A_s0, NA_REAL, NA_REAL);
  internal->b = user_get_scalar_double(user, "b", internal->b, NA_REAL, NA_REAL);
  internal->cA = user_get_scalar_double(user, "cA", internal->cA, NA_REAL, NA_REAL);
  internal->cD = user_get_scalar_double(user, "cD", internal->cD, NA_REAL, NA_REAL);
  internal->cT = user_get_scalar_double(user, "cT", internal->cT, NA_REAL, NA_REAL);
  internal->D_r0 = user_get_scalar_double(user, "D_r0", internal->D_r0, NA_REAL, NA_REAL);
  internal->D_s0 = user_get_scalar_double(user, "D_s0", internal->D_s0, NA_REAL, NA_REAL);
  internal->Ev_r0 = user_get_scalar_double(user, "Ev_r0", internal->Ev_r0, NA_REAL, NA_REAL);
  internal->Ev_s0 = user_get_scalar_double(user, "Ev_s0", internal->Ev_s0, NA_REAL, NA_REAL);
  internal->ft = user_get_scalar_double(user, "ft", internal->ft, NA_REAL, NA_REAL);
  internal->init_res = user_get_scalar_double(user, "init_res", internal->init_res, NA_REAL, NA_REAL);
  internal->Iv_r0 = user_get_scalar_double(user, "Iv_r0", internal->Iv_r0, NA_REAL, NA_REAL);
  internal->Iv_s0 = user_get_scalar_double(user, "Iv_s0", internal->Iv_s0, NA_REAL, NA_REAL);
  internal->m = user_get_scalar_double(user, "m", internal->m, NA_REAL, NA_REAL);
  internal->mu = user_get_scalar_double(user, "mu", internal->mu, NA_REAL, NA_REAL);
  internal->n = user_get_scalar_double(user, "n", internal->n, NA_REAL, NA_REAL);
  internal->phi = user_get_scalar_double(user, "phi", internal->phi, NA_REAL, NA_REAL);
  internal->rA = user_get_scalar_double(user, "rA", internal->rA, NA_REAL, NA_REAL);
  internal->rD = user_get_scalar_double(user, "rD", internal->rD, NA_REAL, NA_REAL);
  internal->res_time = user_get_scalar_double(user, "res_time", internal->res_time, NA_REAL, NA_REAL);
  internal->resistance_dur_mult = user_get_scalar_double(user, "resistance_dur_mult", internal->resistance_dur_mult, NA_REAL, NA_REAL);
  internal->resistance_trans_mult = user_get_scalar_double(user, "resistance_trans_mult", internal->resistance_trans_mult, NA_REAL, NA_REAL);
  internal->rT_r_true = user_get_scalar_double(user, "rT_r_true", internal->rT_r_true, NA_REAL, NA_REAL);
  internal->rT_s = user_get_scalar_double(user, "rT_s", internal->rT_s, NA_REAL, NA_REAL);
  internal->S0 = user_get_scalar_double(user, "S0", internal->S0, NA_REAL, NA_REAL);
  internal->Sv0 = user_get_scalar_double(user, "Sv0", internal->Sv0, NA_REAL, NA_REAL);
  internal->T_r0 = user_get_scalar_double(user, "T_r0", internal->T_r0, NA_REAL, NA_REAL);
  internal->T_s0 = user_get_scalar_double(user, "T_s0", internal->T_s0, NA_REAL, NA_REAL);
  internal->toff = user_get_scalar_double(user, "toff", internal->toff, NA_REAL, NA_REAL);
  internal->ton = user_get_scalar_double(user, "ton", internal->ton, NA_REAL, NA_REAL);
  internal->initial_A_r = internal->A_r0;
  internal->initial_A_s = internal->A_s0;
  internal->initial_D_r = internal->D_r0;
  internal->initial_D_s = internal->D_s0;
  internal->initial_Ev_r = internal->Ev_r0;
  internal->initial_Ev_s = internal->Ev_s0;
  internal->initial_Iv_r = internal->Iv_r0;
  internal->initial_Iv_s = internal->Iv_s0;
  internal->initial_S = internal->S0;
  internal->initial_Sv = internal->Sv0;
  internal->initial_T_r = internal->T_r0;
  internal->initial_T_s = internal->T_s0;
  return R_NilValue;
}
SEXP model_set_initial(SEXP internal_p, SEXP t_ptr, SEXP state_ptr, SEXP model_use_dde_ptr) {
  model_internal *internal = model_get_internal(internal_p, 1);
  const double t = REAL(t_ptr)[0];
  internal->initial_t = t;
  internal->model_use_dde = INTEGER(model_use_dde_ptr)[0];
  if (state_ptr != R_NilValue) {
    double * state = REAL(state_ptr);
    internal->initial_S = state[0];
    internal->initial_D_s = state[1];
    internal->initial_A_s = state[2];
    internal->initial_T_s = state[3];
    internal->initial_D_r = state[4];
    internal->initial_A_r = state[5];
    internal->initial_T_r = state[6];
    internal->initial_Sv = state[7];
    internal->initial_Ev_s = state[8];
    internal->initial_Iv_s = state[9];
    internal->initial_Ev_r = state[10];
    internal->initial_Iv_r = state[11];
  }
  return R_NilValue;
}
SEXP model_metadata(SEXP internal_p) {
  model_internal *internal = model_get_internal(internal_p, 1);
  SEXP ret = PROTECT(allocVector(VECSXP, 4));
  SEXP nms = PROTECT(allocVector(STRSXP, 4));
  SET_STRING_ELT(nms, 0, mkChar("variable_order"));
  SET_STRING_ELT(nms, 1, mkChar("output_order"));
  SET_STRING_ELT(nms, 2, mkChar("n_out"));
  SET_STRING_ELT(nms, 3, mkChar("interpolate_t"));
  setAttrib(ret, R_NamesSymbol, nms);
  SEXP variable_length = PROTECT(allocVector(VECSXP, 12));
  SEXP variable_names = PROTECT(allocVector(STRSXP, 12));
  setAttrib(variable_length, R_NamesSymbol, variable_names);
  SET_VECTOR_ELT(variable_length, 0, R_NilValue);
  SET_VECTOR_ELT(variable_length, 1, R_NilValue);
  SET_VECTOR_ELT(variable_length, 2, R_NilValue);
  SET_VECTOR_ELT(variable_length, 3, R_NilValue);
  SET_VECTOR_ELT(variable_length, 4, R_NilValue);
  SET_VECTOR_ELT(variable_length, 5, R_NilValue);
  SET_VECTOR_ELT(variable_length, 6, R_NilValue);
  SET_VECTOR_ELT(variable_length, 7, R_NilValue);
  SET_VECTOR_ELT(variable_length, 8, R_NilValue);
  SET_VECTOR_ELT(variable_length, 9, R_NilValue);
  SET_VECTOR_ELT(variable_length, 10, R_NilValue);
  SET_VECTOR_ELT(variable_length, 11, R_NilValue);
  SET_STRING_ELT(variable_names, 0, mkChar("S"));
  SET_STRING_ELT(variable_names, 1, mkChar("D_s"));
  SET_STRING_ELT(variable_names, 2, mkChar("A_s"));
  SET_STRING_ELT(variable_names, 3, mkChar("T_s"));
  SET_STRING_ELT(variable_names, 4, mkChar("D_r"));
  SET_STRING_ELT(variable_names, 5, mkChar("A_r"));
  SET_STRING_ELT(variable_names, 6, mkChar("T_r"));
  SET_STRING_ELT(variable_names, 7, mkChar("Sv"));
  SET_STRING_ELT(variable_names, 8, mkChar("Ev_s"));
  SET_STRING_ELT(variable_names, 9, mkChar("Iv_s"));
  SET_STRING_ELT(variable_names, 10, mkChar("Ev_r"));
  SET_STRING_ELT(variable_names, 11, mkChar("Iv_r"));
  SET_VECTOR_ELT(ret, 0, variable_length);
  UNPROTECT(2);
  SEXP output_length = PROTECT(allocVector(VECSXP, 9));
  SEXP output_names = PROTECT(allocVector(STRSXP, 9));
  setAttrib(output_length, R_NamesSymbol, output_names);
  SET_VECTOR_ELT(output_length, 0, R_NilValue);
  SET_VECTOR_ELT(output_length, 1, R_NilValue);
  SET_VECTOR_ELT(output_length, 2, R_NilValue);
  SET_VECTOR_ELT(output_length, 3, R_NilValue);
  SET_VECTOR_ELT(output_length, 4, R_NilValue);
  SET_VECTOR_ELT(output_length, 5, R_NilValue);
  SET_VECTOR_ELT(output_length, 6, R_NilValue);
  SET_VECTOR_ELT(output_length, 7, R_NilValue);
  SET_VECTOR_ELT(output_length, 8, R_NilValue);
  SET_STRING_ELT(output_names, 0, mkChar("prevalence"));
  SET_STRING_ELT(output_names, 1, mkChar("prevalence_res"));
  SET_STRING_ELT(output_names, 2, mkChar("population"));
  SET_STRING_ELT(output_names, 3, mkChar("population_v"));
  SET_STRING_ELT(output_names, 4, mkChar("prevalence_sensitive"));
  SET_STRING_ELT(output_names, 5, mkChar("EIR_s"));
  SET_STRING_ELT(output_names, 6, mkChar("EIR_r"));
  SET_STRING_ELT(output_names, 7, mkChar("EIR_global"));
  SET_STRING_ELT(output_names, 8, mkChar("invading_A_r_out"));
  SET_VECTOR_ELT(ret, 1, output_length);
  UNPROTECT(2);
  SET_VECTOR_ELT(ret, 2, ScalarInteger(9));
  UNPROTECT(2);
  return ret;
}
SEXP model_initial_conditions(SEXP internal_p, SEXP t_ptr) {
  double t = scalar_real(t_ptr, "t");
  model_internal *internal = model_get_internal(internal_p, 1);
  SEXP r_state = PROTECT(allocVector(REALSXP, 12));
  double * state = REAL(r_state);
  state[0] = internal->initial_S;
  state[1] = internal->initial_D_s;
  state[2] = internal->initial_A_s;
  state[3] = internal->initial_T_s;
  state[4] = internal->initial_D_r;
  state[5] = internal->initial_A_r;
  state[6] = internal->initial_T_r;
  state[7] = internal->initial_Sv;
  state[8] = internal->initial_Ev_s;
  state[9] = internal->initial_Iv_s;
  state[10] = internal->initial_Ev_r;
  state[11] = internal->initial_Iv_r;
  UNPROTECT(1);
  return r_state;
}
void model_rhs(model_internal* internal, double t, double * state, double * dstatedt, double * output) {
  double S = state[0];
  double D_s = state[1];
  double A_s = state[2];
  double T_s = state[3];
  double D_r = state[4];
  double A_r = state[5];
  double T_r = state[6];
  double Sv = state[7];
  double Ev_s = state[8];
  double Iv_s = state[9];
  double Ev_r = state[10];
  double Iv_r = state[11];
  // delay block for delayed_lambda_v_r_Sv
  double delayed_lambda_v_r_Sv;
  {
    const double t_true = t;
    const double t = t_true - internal->n;
    double D_r;
    double A_r;
    double T_r;
    double Sv;
    if (t <= internal->initial_t) {
      D_r = internal->initial_D_r;
      A_r = internal->initial_A_r;
      T_r = internal->initial_T_r;
      Sv = internal->initial_Sv;
    } else {
      lagvalue(t, internal->model_use_dde, internal->delay_index_delayed_lambda_v_r_Sv, 4, internal->delay_state_delayed_lambda_v_r_Sv);
      D_r = internal->delay_state_delayed_lambda_v_r_Sv[0];
      A_r = internal->delay_state_delayed_lambda_v_r_Sv[1];
      T_r = internal->delay_state_delayed_lambda_v_r_Sv[2];
      Sv = internal->delay_state_delayed_lambda_v_r_Sv[3];
    }
    double lambda_v_r = internal->a * (internal->cA * A_r + internal->cD * D_r + internal->cT * T_r * (t > internal->ton && t < internal->toff ? internal->resistance_trans_mult : 1));
    delayed_lambda_v_r_Sv = lambda_v_r * Sv * exp(-(internal->mu) * internal->n);
  }
  // delay block for delayed_lambda_v_s_Sv
  double delayed_lambda_v_s_Sv;
  {
    const double t_true = t;
    const double t = t_true - internal->n;
    double D_s;
    double A_s;
    double T_s;
    double Sv;
    if (t <= internal->initial_t) {
      D_s = internal->initial_D_s;
      A_s = internal->initial_A_s;
      T_s = internal->initial_T_s;
      Sv = internal->initial_Sv;
    } else {
      lagvalue(t, internal->model_use_dde, internal->delay_index_delayed_lambda_v_s_Sv, 4, internal->delay_state_delayed_lambda_v_s_Sv);
      D_s = internal->delay_state_delayed_lambda_v_s_Sv[0];
      A_s = internal->delay_state_delayed_lambda_v_s_Sv[1];
      T_s = internal->delay_state_delayed_lambda_v_s_Sv[2];
      Sv = internal->delay_state_delayed_lambda_v_s_Sv[3];
    }
    double lambda_v_s = internal->a * (internal->cA * A_s + internal->cD * D_s + internal->cT * T_s);
    delayed_lambda_v_s_Sv = lambda_v_s * Sv * exp(-(internal->mu) * internal->n);
  }
  double invading_A_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : A_s * log(1 / (double) (1 - internal->init_res)));
  double invading_D_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : D_s * log(1 / (double) (1 - internal->init_res)));
  double invading_Ev_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : Ev_s * log(1 / (double) (1 - internal->init_res)));
  double invading_Iv_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : Iv_s * log(1 / (double) (1 - internal->init_res)));
  double invading_T_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : T_s * log(1 / (double) (1 - internal->init_res)));
  double lambda_r = internal->m * internal->a * internal->b * Iv_r;
  double lambda_s = internal->m * internal->a * internal->b * Iv_s;
  double lambda_v_r = internal->a * (internal->cA * A_r + internal->cD * D_r + internal->cT * T_r * (t > internal->ton && t < internal->toff ? internal->resistance_trans_mult : 1));
  double lambda_v_s = internal->a * (internal->cA * A_s + internal->cD * D_s + internal->cT * T_s);
  double rA_r = internal->rA / (double) (t > internal->ton && t < internal->toff ? internal->resistance_dur_mult : 1);
  double rD_r = internal->rD / (double) (t > internal->ton && t < internal->toff ? internal->resistance_dur_mult : 1);
  double rT_r = ((t > internal->ton && t < internal->toff ? internal->rT_r_true : internal->rT_s));
  dstatedt[5] = invading_A_r + (S * lambda_r * (1 - internal->phi) + lambda_r * A_s * (1 - internal->phi) + D_r * internal->rD - lambda_r * A_r * internal->phi * (1 - internal->ft) - lambda_r * A_r * internal->phi * internal->ft - lambda_s * A_r * internal->phi * (1 - internal->ft) - lambda_s * A_r * internal->phi * internal->ft - lambda_s * A_r * (1 - internal->phi) - A_r * rA_r);
  dstatedt[2] = (S * lambda_s * (1 - internal->phi) + lambda_s * A_r * (1 - internal->phi) + D_s * internal->rD - lambda_s * A_s * internal->phi * (1 - internal->ft) - lambda_s * A_s * internal->phi * internal->ft - lambda_r * A_s * internal->phi * (1 - internal->ft) - lambda_r * A_s * internal->phi * internal->ft - lambda_r * A_s * (1 - internal->phi) - A_s * internal->rA - invading_A_r);
  dstatedt[4] = invading_D_r + (S * lambda_r * internal->phi * (1 - internal->ft) + lambda_r * A_s * internal->phi * (1 - internal->ft) + lambda_r * A_r * internal->phi * (1 - internal->ft) - D_r * rD_r);
  dstatedt[1] = (S * lambda_s * internal->phi * (1 - internal->ft) + lambda_s * A_r * internal->phi * (1 - internal->ft) + lambda_s * A_s * internal->phi * (1 - internal->ft) - D_s * internal->rD) - invading_D_r;
  dstatedt[10] = invading_Ev_r + (lambda_v_r * Sv - delayed_lambda_v_r_Sv - internal->mu * Ev_r);
  dstatedt[8] = lambda_v_s * Sv - delayed_lambda_v_s_Sv - internal->mu * Ev_s - invading_Ev_r;
  dstatedt[11] = invading_Iv_r + (delayed_lambda_v_r_Sv - internal->mu * Iv_r);
  dstatedt[9] = delayed_lambda_v_s_Sv - internal->mu * Iv_s - invading_Iv_r;
  dstatedt[0] = (-(S) * lambda_s * (internal->phi * internal->ft + internal->phi * (1 - internal->ft) + (1 - internal->phi)) - S * lambda_r * (internal->phi * internal->ft + internal->phi * (1 - internal->ft) + (1 - internal->phi)) + T_s * internal->rT_s + A_s * internal->rA + A_r * internal->rA + T_r * rT_r);
  dstatedt[7] = internal->mu - (lambda_v_s + lambda_v_r) * Sv - internal->mu * Sv;
  dstatedt[6] = invading_T_r + (S * lambda_r * internal->phi * internal->ft + lambda_r * A_r * internal->phi * internal->ft + lambda_r * A_s * internal->phi * internal->ft - T_r * rT_r);
  dstatedt[3] = (S * lambda_s * internal->phi * internal->ft + lambda_s * A_r * internal->phi * internal->ft + lambda_s * A_s * internal->phi * internal->ft - T_s * internal->rT_s) - invading_T_r;
  if (output) {
    double EIR_r = internal->m * internal->a * Iv_r * 365;
    double EIR_s = internal->m * internal->a * Iv_s * 365;
    output[2] = S + D_s + A_s + T_s + D_r + A_r + T_r;
    output[3] = Sv + Ev_s + Iv_s + Ev_r + Iv_r;
    output[0] = A_s + D_s + T_s + A_r + D_r + T_r;
    output[1] = (A_r + D_r + T_r) / (double) (A_s + D_s + T_s + A_r + D_r + T_r);
    output[4] = A_s + D_s + T_s;
    double EIR_global = EIR_s + EIR_r;
    output[6] = EIR_r;
    output[5] = EIR_s;
    output[8] = invading_A_r;
    output[7] = EIR_global;
  }
}
void model_rhs_dde(size_t neq, double t, double * state, double * dstatedt, void * internal) {
  model_rhs((model_internal*)internal, t, state, dstatedt, NULL);
}
void model_rhs_desolve(int * neq, double * t, double * state, double * dstatedt, double * output, int * np) {
  model_rhs(model_internal_ds, *t, state, dstatedt, output);
}
void model_output_dde(size_t n_eq, double t, double * state, size_t n_output, double * output, void * internal_p) {
  model_internal *internal = (model_internal*) internal_p;
  double S = state[0];
  double D_s = state[1];
  double A_s = state[2];
  double T_s = state[3];
  double D_r = state[4];
  double A_r = state[5];
  double T_r = state[6];
  double Sv = state[7];
  double Ev_s = state[8];
  double Iv_s = state[9];
  double Ev_r = state[10];
  double Iv_r = state[11];
  double EIR_r = internal->m * internal->a * Iv_r * 365;
  double EIR_s = internal->m * internal->a * Iv_s * 365;
  double invading_A_r = (t < internal->res_time || t > (internal->res_time + 1) ? 0 : A_s * log(1 / (double) (1 - internal->init_res)));
  output[2] = S + D_s + A_s + T_s + D_r + A_r + T_r;
  output[3] = Sv + Ev_s + Iv_s + Ev_r + Iv_r;
  output[0] = A_s + D_s + T_s + A_r + D_r + T_r;
  output[1] = (A_r + D_r + T_r) / (double) (A_s + D_s + T_s + A_r + D_r + T_r);
  output[4] = A_s + D_s + T_s;
  double EIR_global = EIR_s + EIR_r;
  output[6] = EIR_r;
  output[5] = EIR_s;
  output[8] = invading_A_r;
  output[7] = EIR_global;
}
SEXP model_rhs_r(SEXP internal_p, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  model_internal *internal = model_get_internal(internal_p, 1);
  SEXP output_ptr = PROTECT(allocVector(REALSXP, 9));
  setAttrib(dstatedt, install("output"), output_ptr);
  UNPROTECT(1);
  double *output = REAL(output_ptr);
  const double initial_t = internal->initial_t;
  if (ISNA(initial_t)) {
    internal->initial_t = scalar_real(t, "t");
  }
  model_rhs(internal, scalar_real(t, "t"), REAL(state), REAL(dstatedt), output);
  if (ISNA(initial_t)) {
    internal->initial_t = initial_t;
  }
  UNPROTECT(1);
  return dstatedt;
}
double user_get_scalar_double(SEXP user, const char *name,
                              double default_value, double min, double max) {
  double ret = default_value;
  SEXP el = user_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected a scalar numeric for '%s'", name);
    }
    if (TYPEOF(el) == REALSXP) {
      ret = REAL(el)[0];
    } else if (TYPEOF(el) == INTSXP) {
      ret = INTEGER(el)[0];
    } else {
      Rf_error("Expected a numeric value for '%s'", name);
    }
  }
  if (ISNA(ret)) {
    Rf_error("Expected a value for '%s'", name);
  }
  user_check_values_double(&ret, 1, min, max, name);
  return ret;
}
int user_get_scalar_int(SEXP user, const char *name,
                        int default_value, double min, double max) {
  int ret = default_value;
  SEXP el = user_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected scalar integer for '%s'", name);
    }
    if (TYPEOF(el) == REALSXP) {
      double tmp = REAL(el)[0];
      if (fabs(tmp - round(tmp)) > 2e-8) {
        Rf_error("Expected '%s' to be integer-like", name);
      }
    }
    ret = INTEGER(coerceVector(el, INTSXP))[0];
  }
  if (ret == NA_INTEGER) {
    Rf_error("Expected a value for '%s'", name);
  }
  user_check_values_int(&ret, 1, min, max, name);
  return ret;
}
void user_check_values_double(double * value, size_t len,
                                  double min, double max, const char *name) {
  for (size_t i = 0; i < len; ++i) {
    if (ISNA(value[i])) {
      Rf_error("'%s' must not contain any NA values", name);
    }
  }
  if (min != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] < min) {
        Rf_error("Expected '%s' to be at least %g", name, min);
      }
    }
  }
  if (max != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] > max) {
        Rf_error("Expected '%s' to be at most %g", name, max);
      }
    }
  }
}
void user_check_values_int(int * value, size_t len,
                               double min, double max, const char *name) {
  for (size_t i = 0; i < len; ++i) {
    if (ISNA(value[i])) {
      Rf_error("'%s' must not contain any NA values", name);
    }
  }
  if (min != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] < min) {
        Rf_error("Expected '%s' to be at least %g", name, min);
      }
    }
  }
  if (max != NA_REAL) {
    for (size_t i = 0; i < len; ++i) {
      if (value[i] > max) {
        Rf_error("Expected '%s' to be at most %g", name, max);
      }
    }
  }
}
void user_check_values(SEXP value, double min, double max,
                           const char *name) {
  size_t len = (size_t)length(value);
  if (TYPEOF(value) == INTSXP) {
    user_check_values_int(INTEGER(value), len, min, max, name);
  } else {
    user_check_values_double(REAL(value), len, min, max, name);
  }
}
SEXP user_list_element(SEXP list, const char *name) {
  SEXP ret = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  for (int i = 0; i < length(list); ++i) {
    if (strcmp(CHAR(STRING_ELT(names, i)), name) == 0) {
      ret = VECTOR_ELT(list, i);
      break;
    }
  }
  return ret;
}
void lagvalue(double t, bool use_dde, int *idx, int dim_idx, double *state) {
  if (use_dde) {
    lagvalue_dde(t, idx, dim_idx, state);
  } else {
    lagvalue_ds(t, idx, dim_idx, state);
  }
}
void lagvalue_dde(double t, int *idx, size_t dim_idx, double *state) {
  typedef void (*lagvalue_type)(double, int*, size_t, double*);
  static lagvalue_type fun = NULL;
  if (fun == NULL) {
    fun = (lagvalue_type)R_GetCCallable("dde", "ylag_vec_int");
  }
  fun(t, idx, dim_idx, state);
}
void lagvalue_ds(double t, int *idx, int dim_idx, double *state) {
  typedef void (*lagvalue_type)(double, int*, int, double*);
  static lagvalue_type fun = NULL;
  if (fun == NULL) {
    fun = (lagvalue_type)R_GetCCallable("deSolve", "lagvalue");
  }
  fun(t, idx, dim_idx, state);
}
double scalar_real(SEXP x, const char * name) {
  if (Rf_length(x) != 1) {
    Rf_error("Expected a scalar for '%s'", name);
  }
  double ret = 0.0;
  if (TYPEOF(x) == INTSXP) {
    ret = INTEGER(x)[0];
  } else if (TYPEOF(x) == REALSXP) {
    ret = REAL(x)[0];
  } else {
    Rf_error("Expected a numeric value for '%s'", name);
  }
  return ret;
}
